#pragma kernel buildVoxelGrid
#pragma kernel sampleCornerDensities
#pragma kernel calculateMinimizingVertices

struct SymmetricMatrix3x3 {
    float m00, m01, m02, m11, m12, m22;
};

SymmetricMatrix3x3 createSymmetricMatrix3x3( ) {
    SymmetricMatrix3x3 symmetricMatrix3x3;

    symmetricMatrix3x3.m00 = 0.0f;
    symmetricMatrix3x3.m01 = 0.0f;
    symmetricMatrix3x3.m02 = 0.0f;
    symmetricMatrix3x3.m11 = 0.0f;
    symmetricMatrix3x3.m12 = 0.0f;
    symmetricMatrix3x3.m22 = 0.0f;

    return symmetricMatrix3x3;
}


struct SVDQEF {
    SymmetricMatrix3x3 ATA;
    float3             ATB;
    float              BTB;
    float3             massPoint;
    uint               intersectionCount;
};

SVDQEF createSVDQEF( ) {
    SVDQEF svdqef;

    svdqef.ATA               = createSymmetricMatrix3x3( );
    svdqef.ATB               = float3( 0.0f, 0.0f, 0.0f );
    svdqef.BTB               = 0.0f;
    svdqef.massPoint         = float3( 0.0f, 0.0f, 0.0f );
    svdqef.intersectionCount = 0;

    return svdqef;
}

#define MATERIAL_INDEX_VOID 0
#define MATERIAL_INDEX_MATERIAL1 1
#define MATERIAL_INDEX_MATERIAL2 2
#define MATERIAL_INDEX_MATERIAL3 4
#define MATERIAL_INDEX_MATERIAL4 8
#define MATERIAL_INDEX_MATERIAL5 16
#define MATERIAL_INDEX_MATERIAL6 32
#define MATERIAL_INDEX_MATERIAL7 64
#define MATERIAL_INDEX_MATERIAL8 128
#define MATERIAL_INDEX_MATERIAL9 256

struct Corner {
    float3 position;
    float  density;
    uint   materialIndex;
};

Corner createCorner( float3 position ) {
    Corner corner;

    corner.position      = position;
    corner.density       = 0.0f;
    corner.materialIndex = 0;

    return corner;
}

struct Edge {
    float3 intersection;
    float3 normal;
};

Edge createEdge( ) {
    Edge edge;

    edge.intersection = float3( 0.0f, 0.0f, 0.0f );
    edge.normal       = float3( 0.0f, 0.0f, 0.0f );

    return edge;
}

#define VOXEL_CORNER_COUNT 8
#define VOXEL_EDGE_COUNT 12

struct Voxel {
    float3 center;
    float3 size;
    float3 extents;
    float3 minimum;
    float3 maximum;
    SVDQEF qef;
    float3 vertex;
    float3 normal;
    int    index;
};

Voxel createVoxel( float3 center, float3 size ) {
    Voxel voxel;

    voxel.center  = center;
    voxel.size    = size;
    voxel.extents = size / 2;
    voxel.minimum = center - voxel.extents;
    voxel.maximum = center + voxel.extents;
    voxel.qef     = createSVDQEF( );
    voxel.vertex  = float3( 0.0f, 0.0f, 0.0f );
    voxel.normal  = float3( 0.0f, 0.0f, 0.0f );
    voxel.index   = -1;

    return voxel;
}

#define DENSITY_FUNCTION_TYPE_CUBOID 0
#define DENSITY_FUNCTION_TYPE_ELLIPSOID 1

#define DENSITY_FUNCTION_COMBINATION_UNION 0
#define DENSITY_FUNCTION_COMBINATION_INTERSECTION 1
#define DENSITY_FUNCTION_COMBINATION_SUBTRACTION 2

struct DensityFunction {
    uint   type;
    uint   combination;
    uint   materialIndex;
    float3 origin;
    float3 extents;
};

// element-wise multiply
float3 multiply( float3 v1, float3 v2 ) {
    return float3( v1.x * v2.x, v1.y * v2.y, v1.z * v2.z );
}

// element-wise divide
float3 divide( float3 v1, float3 v2 ) {
    return float3( v1.x / v2.x, v1.y / v2.y, v1.z / v2.z );
}

// element-wise absolute value
float3 absolute( float3 v ) {
    return float3( abs( v.x ), abs( v.y ), abs( v.z ) );
}

float3 maximum( float3 v1, float3 v2 ) {
    return float3( max( v1.x, v2.x ), max( v1.y, v2.x ), max( v1.z, v2.x ) );
}

float sampleCuboid( float3 position, DensityFunction densityFunction ) {
    float3 q = absolute( position - densityFunction.origin ) - densityFunction.extents;
    return length( max( q, float3( 0.0f, 0.0f, 0.0f ) ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0f );
}

float sampleEllipsoid( float3 position, DensityFunction densityFunction ) {
    // avoid division by zero
    if( length( position - densityFunction.origin ) == 0.0f ) {
        return -1.0f;
    }

    float k0 = length( divide( ( position - densityFunction.origin ), densityFunction.extents ) );
    float k1 = length( divide( ( position - densityFunction.origin ), multiply( densityFunction.extents, densityFunction.extents ) ) );

    return k0 * ( k0 - 1.0f ) / k1;
}

float sampleDensityFunction( float3 position, DensityFunction densityFunction ) {
    switch( densityFunction.type ) {
        case DENSITY_FUNCTION_TYPE_CUBOID:
            return sampleCuboid( position, densityFunction );
        case DENSITY_FUNCTION_TYPE_ELLIPSOID:
            return sampleEllipsoid( position, densityFunction );
        default:
            return 0.0f;
    }
}

cbuffer Configuration {
    uint resolution;
    uint minimizerIterations;
    uint binarySearchIterations;
    uint surfaceCorrectionIterations;
    uint intersectionApproximationMode;
    uint densityFunctionCount;
}

RWStructuredBuffer<Voxel>  voxels;
RWStructuredBuffer<Corner> corners;
RWStructuredBuffer<Edge>   edges;

[numthreads( 1, 1, 1 )]
void buildVoxelGrid( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    float3 size   = float3( 1.0f, 1.0f, 1.0f ) / resolution;                                                // center voxel relative to 0, 0, 0
    float3 center = ( float3( dispatchThreadID.x, dispatchThreadID.y, dispatchThreadID.z ) / resolution ) - ( size / 2 * ( resolution - 1 ) );

    voxels[voxelIndex] = createVoxel( center, size );

    uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT );

    corners[cornerIndex + 0] = createCorner( voxels[voxelIndex].minimum );
    corners[cornerIndex + 1] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 2] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 3] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 4] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 5] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 6] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 7] = createCorner( voxels[voxelIndex].maximum );

    uint edgeIndex = ( voxelIndex * VOXEL_EDGE_COUNT );

    edges[edgeIndex +  0] = createEdge( );
    edges[edgeIndex +  1] = createEdge( );
    edges[edgeIndex +  2] = createEdge( );
    edges[edgeIndex +  3] = createEdge( );
    edges[edgeIndex +  4] = createEdge( );
    edges[edgeIndex +  5] = createEdge( );
    edges[edgeIndex +  6] = createEdge( );
    edges[edgeIndex +  7] = createEdge( );
    edges[edgeIndex +  8] = createEdge( );
    edges[edgeIndex +  9] = createEdge( );
    edges[edgeIndex + 10] = createEdge( );
    edges[edgeIndex + 11] = createEdge( );
}

RWStructuredBuffer<DensityFunction> densityFunctions;

[numthreads( 1, 1, 1 )]
void sampleCornerDensities( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    for( uint voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {

        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        for( uint densityFunctionIndex = 0; densityFunctionIndex < densityFunctionCount; ++densityFunctionIndex ) {

            float density       = sampleDensityFunction( corners[cornerIndex].position, densityFunctions[densityFunctionIndex] );
            uint  materialIndex = corners[cornerIndex].materialIndex;

            // set material bit if the corner is inside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_UNION && density < 0.0f ) {
                materialIndex |= densityFunctions[densityFunctionIndex].materialIndex;
            }
            // unset material bit if the corner is outside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_INTERSECTION && density > 0.0f ) {
                materialIndex &= ~densityFunctions[densityFunctionIndex].materialIndex;
            }
            // unset material bit if the corner is inside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_SUBTRACTION && density < 0.0f ) {
                materialIndex &= ~densityFunctions[densityFunctionIndex].materialIndex;
            }

            switch( densityFunctions[densityFunctionIndex].combination ) {
                case DENSITY_FUNCTION_COMBINATION_UNION:
                    density = min( corners[cornerIndex].density,  density );
                    break;
                case DENSITY_FUNCTION_COMBINATION_INTERSECTION:
                    density = max( corners[cornerIndex].density,  density );
                    break;
                case DENSITY_FUNCTION_COMBINATION_SUBTRACTION:
                    density = max( corners[cornerIndex].density, -density );
                    break;
            }

            corners[cornerIndex].density       = density;
            corners[cornerIndex].materialIndex = materialIndex;
        }
    }
}

uint2 lookupCornerInEdge( uint voxelEdgeIndex ) {
    switch( voxelEdgeIndex ) {
        case  0: return uint2( 0, 1 );
        case  1: return uint2( 3, 2 );
        case  2: return uint2( 5, 6 );
        case  3: return uint2( 4, 7 );
        case  4: return uint2( 0, 5 );
        case  5: return uint2( 1, 6 );
        case  6: return uint2( 3, 4 );
        case  7: return uint2( 2, 7 );
        case  8: return uint2( 0, 3 );
        case  9: return uint2( 1, 2 );
        case 10: return uint2( 5, 4 );
        case 11: return uint2( 6, 7 );
        default: return uint2( 0, 0 );
    }
}

[numthreads( 1, 1 ,1 )]
void calculateMinimizingVertices( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    bool allEmpty = true;
    bool allSolid = true;

    [unroll]
    for( uint voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {
        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        if( corners[cornerIndex].materialIndex >= MATERIAL_INDEX_VOID ) {
            allEmpty = false;
            break;
        }
    }

    [unroll]
    for( voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {
        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        if( corners[cornerIndex].materialIndex == MATERIAL_INDEX_VOID ) {
            allSolid = false;
            break;
        }
    }

    if( !( allEmpty && allSolid ) ) {

        for( uint voxelEdgeIndex = 0; voxelEdgeIndex < VOXEL_EDGE_COUNT; ++voxelEdgeIndex ) {
            uint edgeIndex = ( voxelIndex * VOXEL_EDGE_COUNT ) + voxelEdgeIndex;

            uint2 voxelCornerIndices = lookupCornerInEdge( voxelEdgeIndex );

            uint cornerIndex0 = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndices[0];
            uint cornerIndex1 = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndices[1];

            bool intersectsContour = (
                corners[cornerIndex0].materialIndex == MATERIAL_INDEX_VOID && corners[cornerIndex1].materialIndex >= MATERIAL_INDEX_VOID
            ) || (
                corners[cornerIndex1].materialIndex == MATERIAL_INDEX_VOID && corners[cornerIndex0].materialIndex >= MATERIAL_INDEX_VOID
            );

            if( intersectsContour ) {

                // TODO

            }
        }
    }

    /*
    if(
        voxel.corners.All( ( corner ) => corner.materialIndex == MaterialIndex.Void      ) ||
        voxel.corners.All( ( corner ) => corner.materialIndex >= MaterialIndex.Material1 )
    ) {
        // cell is either fully inside or outside the volume, skip
        continue;
    }

    voxel.qef = qefSolverType switch {
        QEFSolverType.Simple => new SimpleQEF ( minimizerIterations, surfaceCorrectionIterations ),
        QEFSolverType.SVD    => new SVDQEF    ( minimizerIterations, surfaceCorrectionIterations ),
        _                    => throw new Exception( "Unknown solver type specified" )
    };

    foreach( var edge in voxel.edges ) {
        if( !edge.intersectsContour( ) ) {
            continue;
        }

        edge.intersection = SurfaceExtractor.approximateIntersection ( edge, densityFunctions, intersectionApproximation, binarySearchIterations );
        edge.normal       = SurfaceExtractor.calculateNormal         ( edge, densityFunctions );

        voxel.qef.add( edge.intersection, edge.normal );
    }

    ( voxel.vertex, voxel.normal, _ ) = voxel.qef.solve( voxel, densityFunctions );

    voxel.index = index++;
    */
}