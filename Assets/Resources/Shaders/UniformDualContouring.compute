#pragma kernel buildVoxelGrid
#pragma kernel sampleCornerDensities
#pragma kernel calculateMinimizingVertices

struct SymmetricMatrix3x3 {
    float m00, m01, m02, m11, m12, m22;
};

SymmetricMatrix3x3 createSymmetricMatrix3x3( ) {
    SymmetricMatrix3x3 symmetricMatrix3x3;

    symmetricMatrix3x3.m00 = 0.0f;
    symmetricMatrix3x3.m01 = 0.0f;
    symmetricMatrix3x3.m02 = 0.0f;
    symmetricMatrix3x3.m11 = 0.0f;
    symmetricMatrix3x3.m12 = 0.0f;
    symmetricMatrix3x3.m22 = 0.0f;

    return symmetricMatrix3x3;
}

SymmetricMatrix3x3 createSymmetricMatrix3x3(
    float m00,
    float m01,
    float m02,
    float m11,
    float m12,
    float m22
) {
    SymmetricMatrix3x3 symmetricMatrix3x3;

    symmetricMatrix3x3.m00 = m00;
    symmetricMatrix3x3.m01 = m01;
    symmetricMatrix3x3.m02 = m02;
    symmetricMatrix3x3.m11 = m11;
    symmetricMatrix3x3.m12 = m12;
    symmetricMatrix3x3.m22 = m22;

    return symmetricMatrix3x3;
}

struct Matrix3x3 {
    float m00, m01, m02, m10, m11, m12, m20, m21, m22;
};

Matrix3x3 createMatrix3x3( ) {
    Matrix3x3 matrix3x3;

    matrix3x3.m00 = 0.0f;
    matrix3x3.m01 = 0.0f;
    matrix3x3.m02 = 0.0f;
    matrix3x3.m10 = 0.0f;
    matrix3x3.m11 = 0.0f;
    matrix3x3.m12 = 0.0f;
    matrix3x3.m20 = 0.0f;
    matrix3x3.m21 = 0.0f;
    matrix3x3.m22 = 0.0f;

    return matrix3x3;
}

Matrix3x3 createMatrix3x3(
    float m00,
    float m01,
    float m02,
    float m10,
    float m11,
    float m12,
    float m20,
    float m21,
    float m22
) {
    Matrix3x3 matrix3x3;

    matrix3x3.m00 = m00;
    matrix3x3.m01 = m01;
    matrix3x3.m02 = m02;
    matrix3x3.m10 = m10;
    matrix3x3.m11 = m11;
    matrix3x3.m12 = m12;
    matrix3x3.m20 = m20;
    matrix3x3.m21 = m21;
    matrix3x3.m22 = m22;

    return matrix3x3;
}

Matrix3x3 createMatrix3x3( SymmetricMatrix3x3 symmetricMatrix3x3 ) {
    Matrix3x3 matrix3x3;

    matrix3x3.m00 = symmetricMatrix3x3.m00;
    matrix3x3.m01 = symmetricMatrix3x3.m01;
    matrix3x3.m02 = symmetricMatrix3x3.m02;
    matrix3x3.m10 = 0.0f;
    matrix3x3.m11 = symmetricMatrix3x3.m11;
    matrix3x3.m12 = symmetricMatrix3x3.m12;
    matrix3x3.m20 = 0.0f;
    matrix3x3.m21 = 0.0f;
    matrix3x3.m22 = symmetricMatrix3x3.m22;

    return matrix3x3;
}

struct SVDQEF {
    SymmetricMatrix3x3 ATA;
    float3             ATB;
    float              BTB;
    float3             massPoint;
    uint               intersectionCount;
};

SVDQEF createSVDQEF( ) {
    SVDQEF svdqef;

    svdqef.ATA               = createSymmetricMatrix3x3( );
    svdqef.ATB               = float3( 0.0f, 0.0f, 0.0f );
    svdqef.BTB               = 0.0f;
    svdqef.massPoint         = float3( 0.0f, 0.0f, 0.0f );
    svdqef.intersectionCount = 0;

    return svdqef;
}

#define MATERIAL_INDEX_VOID 0
#define MATERIAL_INDEX_MATERIAL1 1
#define MATERIAL_INDEX_MATERIAL2 2
#define MATERIAL_INDEX_MATERIAL3 4
#define MATERIAL_INDEX_MATERIAL4 8
#define MATERIAL_INDEX_MATERIAL5 16
#define MATERIAL_INDEX_MATERIAL6 32
#define MATERIAL_INDEX_MATERIAL7 64
#define MATERIAL_INDEX_MATERIAL8 128
#define MATERIAL_INDEX_MATERIAL9 256

struct Corner {
    float3 position;
    float  density;
    uint   materialIndex;
};

Corner createCorner( float3 position ) {
    Corner corner;

    corner.position      = position;
    corner.density       = 0.0f;
    corner.materialIndex = 0;

    return corner;
}

struct Edge {
    float3 intersection;
    float3 normal;
};

Edge createEdge( ) {
    Edge edge;

    edge.intersection = float3( 0.0f, 0.0f, 0.0f );
    edge.normal       = float3( 0.0f, 0.0f, 0.0f );

    return edge;
}

#define VOXEL_CORNER_COUNT 8
#define VOXEL_EDGE_COUNT 12

struct Voxel {
    float3 center;
    float3 size;
    float3 extents;
    float3 minimum;
    float3 maximum;
    SVDQEF qef;
    float3 vertex;
    float3 normal;
    int    index;
};

Voxel createVoxel( float3 center, float3 size ) {
    Voxel voxel;

    voxel.center  = center;
    voxel.size    = size;
    voxel.extents = size / 2;
    voxel.minimum = center - voxel.extents;
    voxel.maximum = center + voxel.extents;
    voxel.qef     = createSVDQEF( );
    voxel.vertex  = float3( 0.0f, 0.0f, 0.0f );
    voxel.normal  = float3( 0.0f, 0.0f, 0.0f );
    voxel.index   = -1;

    return voxel;
}

#define DENSITY_FUNCTION_TYPE_CUBOID 0
#define DENSITY_FUNCTION_TYPE_ELLIPSOID 1

#define DENSITY_FUNCTION_COMBINATION_UNION 0
#define DENSITY_FUNCTION_COMBINATION_INTERSECTION 1
#define DENSITY_FUNCTION_COMBINATION_SUBTRACTION 2

struct DensityFunction {
    uint   type;
    uint   combination;
    uint   materialIndex;
    float3 origin;
    float3 extents;
};

// element-wise multiply
float3 multiply( float3 v1, float3 v2 ) {
    return float3( v1.x * v2.x, v1.y * v2.y, v1.z * v2.z );
}

// element-wise divide
float3 divide( float3 v1, float3 v2 ) {
    return float3( v1.x / v2.x, v1.y / v2.y, v1.z / v2.z );
}

// element-wise absolute value
float3 absolute( float3 v ) {
    return float3( abs( v.x ), abs( v.y ), abs( v.z ) );
}

float3 maximum( float3 v1, float3 v2 ) {
    return float3( max( v1.x, v2.x ), max( v1.y, v2.x ), max( v1.z, v2.x ) );
}

float sampleCuboid( float3 position, DensityFunction densityFunction ) {
    float3 q = absolute( position - densityFunction.origin ) - densityFunction.extents;
    return length( max( q, float3( 0.0f, 0.0f, 0.0f ) ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0f );
}

float sampleEllipsoid( float3 position, DensityFunction densityFunction ) {
    // avoid division by zero
    if( length( position - densityFunction.origin ) == 0.0f ) {
        return -1.0f;
    }

    float k0 = length( divide( ( position - densityFunction.origin ), densityFunction.extents ) );
    float k1 = length( divide( ( position - densityFunction.origin ), multiply( densityFunction.extents, densityFunction.extents ) ) );

    return k0 * ( k0 - 1.0f ) / k1;
}

float sampleDensityFunction( float3 position, DensityFunction densityFunction ) {
    switch( densityFunction.type ) {
        case DENSITY_FUNCTION_TYPE_CUBOID:
            return sampleCuboid( position, densityFunction );
        case DENSITY_FUNCTION_TYPE_ELLIPSOID:
            return sampleEllipsoid( position, densityFunction );
        default:
            return 0.0f;
    }
}

#define INTERSECTION_APPROXIMATION_BINARY_SEARCH 0
#define INTERSECTION_APPROXIMATION_LINEAR_INTERPOLATION 1

cbuffer Configuration {
    uint resolution;
    uint minimizerIterations;
    uint binarySearchIterations;
    uint surfaceCorrectionIterations;
    uint intersectionApproximation;
    uint densityFunctionCount;
}

RWStructuredBuffer<Voxel>  voxels;
RWStructuredBuffer<Corner> corners;
RWStructuredBuffer<Edge>   edges;

[numthreads( 1, 1, 1 )]
void buildVoxelGrid( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    float3 size   = float3( 1.0f, 1.0f, 1.0f ) / resolution;                                                // center voxel relative to 0, 0, 0
    float3 center = ( float3( dispatchThreadID.x, dispatchThreadID.y, dispatchThreadID.z ) / resolution ) - ( size / 2 * ( resolution - 1 ) );

    voxels[voxelIndex] = createVoxel( center, size );

    uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT );

    corners[cornerIndex + 0] = createCorner( voxels[voxelIndex].minimum );
    corners[cornerIndex + 1] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 2] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 3] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].minimum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 4] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].maximum.z ) );
    corners[cornerIndex + 5] = createCorner( float3( voxels[voxelIndex].minimum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 6] = createCorner( float3( voxels[voxelIndex].maximum.x, voxels[voxelIndex].maximum.y, voxels[voxelIndex].minimum.z ) );
    corners[cornerIndex + 7] = createCorner( voxels[voxelIndex].maximum );

    uint edgeIndex = ( voxelIndex * VOXEL_EDGE_COUNT );

    edges[edgeIndex +  0] = createEdge( );
    edges[edgeIndex +  1] = createEdge( );
    edges[edgeIndex +  2] = createEdge( );
    edges[edgeIndex +  3] = createEdge( );
    edges[edgeIndex +  4] = createEdge( );
    edges[edgeIndex +  5] = createEdge( );
    edges[edgeIndex +  6] = createEdge( );
    edges[edgeIndex +  7] = createEdge( );
    edges[edgeIndex +  8] = createEdge( );
    edges[edgeIndex +  9] = createEdge( );
    edges[edgeIndex + 10] = createEdge( );
    edges[edgeIndex + 11] = createEdge( );
}

RWStructuredBuffer<DensityFunction> densityFunctions;

[numthreads( 1, 1, 1 )]
void sampleCornerDensities( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    for( uint voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {

        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        for( uint densityFunctionIndex = 0; densityFunctionIndex < densityFunctionCount; ++densityFunctionIndex ) {

            float density       = sampleDensityFunction( corners[cornerIndex].position, densityFunctions[densityFunctionIndex] );
            uint  materialIndex = corners[cornerIndex].materialIndex;

            // set material bit if the corner is inside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_UNION && density < 0.0f ) {
                materialIndex |= densityFunctions[densityFunctionIndex].materialIndex;
            }
            // unset material bit if the corner is outside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_INTERSECTION && density > 0.0f ) {
                materialIndex &= ~densityFunctions[densityFunctionIndex].materialIndex;
            }
            // unset material bit if the corner is inside of the shape
            if( densityFunctions[densityFunctionIndex].combination == DENSITY_FUNCTION_COMBINATION_SUBTRACTION && density < 0.0f ) {
                materialIndex &= ~densityFunctions[densityFunctionIndex].materialIndex;
            }

            switch( densityFunctions[densityFunctionIndex].combination ) {
                case DENSITY_FUNCTION_COMBINATION_UNION:
                    density = min( corners[cornerIndex].density,  density );
                    break;
                case DENSITY_FUNCTION_COMBINATION_INTERSECTION:
                    density = max( corners[cornerIndex].density,  density );
                    break;
                case DENSITY_FUNCTION_COMBINATION_SUBTRACTION:
                    density = max( corners[cornerIndex].density, -density );
                    break;
            }

            corners[cornerIndex].density       = density;
            corners[cornerIndex].materialIndex = materialIndex;
        }
    }
}

uint2 lookupCornersInEdge( uint voxelEdgeIndex ) {
    switch( voxelEdgeIndex ) {
        case  0: return uint2( 0, 1 );
        case  1: return uint2( 3, 2 );
        case  2: return uint2( 5, 6 );
        case  3: return uint2( 4, 7 );
        case  4: return uint2( 0, 5 );
        case  5: return uint2( 1, 6 );
        case  6: return uint2( 3, 4 );
        case  7: return uint2( 2, 7 );
        case  8: return uint2( 0, 3 );
        case  9: return uint2( 1, 2 );
        case 10: return uint2( 5, 4 );
        case 11: return uint2( 6, 7 );
        default: return uint2( 0, 0 );
    }
}

#define NEGATIVE_INFINITY 3.402823466e-38F
#define POSITIVE_INFINITY 3.402823466e+38F

float calculateDensity( float3 position ) {

    float density = POSITIVE_INFINITY;

    for( uint densityFunctionIndex = 0; densityFunctionIndex < densityFunctionCount; ++densityFunctionIndex ) {

        switch( densityFunctions[densityFunctionIndex].combination ) {
            case DENSITY_FUNCTION_COMBINATION_UNION:
                density = min( density,  sampleDensityFunction( position, densityFunctions[densityFunctionIndex] ) );
                break;
            case DENSITY_FUNCTION_COMBINATION_INTERSECTION:
                density = max( density,  sampleDensityFunction( position, densityFunctions[densityFunctionIndex] ) );
                break;
            case DENSITY_FUNCTION_COMBINATION_SUBTRACTION:
                density = max( density, -sampleDensityFunction( position, densityFunctions[densityFunctionIndex] ) );
                break;
            default:
                density = 0.0f;
                break;
        }
    }

    return density;
}

float3 approximateIntersection( Corner corner0, Corner corner1 ) {
    if( corner0.density == 0.0f || corner1.density == 0.0f ) {
        // one of the corners is at the exact intersection
        return corner0.density == 0.0f ? corner0.position : corner1.position;
    }

    if( intersectionApproximation == INTERSECTION_APPROXIMATION_BINARY_SEARCH ) {

        float3 start = float3( 0.0f, 0.0f, 0.0f );
        float3 end   = float3( 0.0f, 0.0f, 0.0f );
        if( corner0.density < corner1.density ) {
            start = corner0.position;
            end   = corner1.position;
        }
        else {
            start = corner1.position;
            end   = corner0.position;
        }

        float3 intersection = float3( 0.0f, 0.0f, 0.0f );
        for( uint binarySearchIteration = 0; binarySearchIteration < binarySearchIterations; ++binarySearchIteration ) {
            intersection = start + ( 0.5f * ( end - start ) );

            float density = calculateDensity( intersection );

            if( density < 0.0f ) {
                start = intersection;
            }
            else if( density > 0.0f ) {
                end = intersection;
            }
            else if( density == 0.0f ) {
                break;
            }
        }
    }
    else if( intersectionApproximation == INTERSECTION_APPROXIMATION_LINEAR_INTERPOLATION ) {
        return corner0.position + ( ( -corner0.density ) * ( corner1.position - corner0.position ) / ( corner1.density - corner0.density ) );
    }

    return float3( 0.0f, 0.0f, 0.0f );
}

#define STEP 0.1f

float3 calculateNormal( float3 position ) {

    // sample surrounding x, y, z locations and take the difference

    float3 positive = float3( POSITIVE_INFINITY, POSITIVE_INFINITY, POSITIVE_INFINITY );

    positive.x = calculateDensity( position + float3( STEP, 0.0f, 0.0f ) );
    positive.y = calculateDensity( position + float3( 0.0f, STEP, 0.0f ) );
    positive.z = calculateDensity( position + float3( 0.0f, 0.0f, STEP ) );

    float3 negative = float3( POSITIVE_INFINITY, POSITIVE_INFINITY, POSITIVE_INFINITY );

    negative.x = calculateDensity( position - float3( STEP, 0.0f, 0.0f ) );
    negative.y = calculateDensity( position - float3( 0.0f, STEP, 0.0f ) );
    negative.z = calculateDensity( position - float3( 0.0f, 0.0f, STEP ) );

    return normalize( positive - negative );
}

void addToQEF( in out SVDQEF qef, float3 intersection, float3 normal ) {
    qef.ATA.m00 += normal.x * normal.x;
    qef.ATA.m01 += normal.x * normal.y;
    qef.ATA.m02 += normal.x * normal.z;
    qef.ATA.m11 += normal.y * normal.y;
    qef.ATA.m12 += normal.y * normal.z;
    qef.ATA.m22 += normal.z * normal.z;

    float x = dot( intersection, normal );

    qef.ATB       += x * normal;
    qef.BTB       += x * x;
    qef.massPoint += intersection;

    ++qef.intersectionCount;
}

float3 surfaceCorrection( float3 vertex, float3 normal ) {
    for( uint surfaceCorrectionIteration = 0; surfaceCorrectionIteration < surfaceCorrectionIterations; ++surfaceCorrectionIteration ) {
        float density = calculateDensity( vertex );
        if( density == 0.0f ) {
            // vertex is at the surface
            break;
        }
        vertex -= normal * density;
    }
    return vertex;
}

float3 multiplyVector( SymmetricMatrix3x3 m, float3 v ) {
    return float3(
        ( m.m00 * v.x ) + ( m.m01 * v.y ) + ( m.m02 * v.z ),
        ( m.m01 * v.x ) + ( m.m11 * v.y ) + ( m.m12 * v.z ),
        ( m.m02 * v.x ) + ( m.m12 * v.y ) + ( m.m22 * v.z )
    );
}

float3 multiplyVector( Matrix3x3 m, float3 v ) {
    return float3(
        ( m.m00 * v.x ) + ( m.m01 * v.y ) + ( m.m02 * v.z ),
        ( m.m10 * v.x ) + ( m.m11 * v.y ) + ( m.m12 * v.z ),
        ( m.m20 * v.x ) + ( m.m21 * v.y ) + ( m.m22 * v.z )
    );
}

float frobeniusNorm( SymmetricMatrix3x3 VTAV ) {
    return sqrt(
        ( VTAV.m00 * VTAV.m00 ) + ( VTAV.m01 * VTAV.m01 ) + ( VTAV.m02 * VTAV.m02 ) +
        ( VTAV.m01 * VTAV.m01 ) + ( VTAV.m11 * VTAV.m11 ) + ( VTAV.m12 * VTAV.m12 ) +
        ( VTAV.m02 * VTAV.m02 ) + ( VTAV.m12 * VTAV.m12 ) + ( VTAV.m22 * VTAV.m22 )
    );
}

float off( SymmetricMatrix3x3 VTAV ) {
    return sqrt( 2 * ( ( VTAV.m01 * VTAV.m01 ) + ( VTAV.m02 * VTAV.m02 ) + ( VTAV.m12 * VTAV.m12 ) ) );
}

#define SVD_TOLERANCE 1e-6f
#define PSEUDO_INVERSE_TOLERANCE 1e-6f

void calculateSymmetricGivensCoefficients( float app, float apq, float aqq, out float c, out float s ) {
    if( apq != 0.0f ) {
        float tau = ( aqq - app ) / ( 2.0f * apq );
        float stt = sqrt( 1.0f + ( tau * tau ) );
        float tan = 1.0f / ( tau >= 0.0f ? tau + stt : tau - stt );

        c = 1.0f / sqrt( 1.0f + ( tan * tan ) );
        s = tan * c;
    }
}

SymmetricMatrix3x3 rotate01( SymmetricMatrix3x3 VTAV, float c, float s ) {
    float cc  = c * c;
    float ss  = s * s;
    float mix = 2 * c * s * VTAV.m01;

    return createSymmetricMatrix3x3(
        ( cc * VTAV.m00 ) - mix + ( ss * VTAV.m11 ),
        0.0f,
        ( c  * VTAV.m02 ) -       ( s  * VTAV.m12 ),
        ( ss * VTAV.m00 ) + mix + ( cc * VTAV.m11 ),
        ( s  * VTAV.m02 ) +       ( c  * VTAV.m12 ),
        VTAV.m22
    );
}

SymmetricMatrix3x3 rotate02( SymmetricMatrix3x3 VTAV, float c, float s ) {
    float cc  = c * c;
    float ss  = s * s;
    float mix = 2 * c * s * VTAV.m02;

    return createSymmetricMatrix3x3(
        ( cc * VTAV.m00 ) - mix + ( ss * VTAV.m22 ),
        ( c  * VTAV.m01 ) -       ( s  * VTAV.m12 ),
        0.0f,
        VTAV.m11,
        ( s  * VTAV.m01 ) +       ( c  * VTAV.m12 ),
        ( ss * VTAV.m00 ) + mix + ( cc * VTAV.m22 )
    );
}

SymmetricMatrix3x3 rotate12( SymmetricMatrix3x3 VTAV, float c, float s ) {
    float cc  = c * c;
    float ss  = s * s;
    float mix = 2 * c * s * VTAV.m12;

    return createSymmetricMatrix3x3(
        VTAV.m00,
        ( c  * VTAV.m01 ) -       ( s  * VTAV.m02 ),
        ( s  * VTAV.m01 ) +       ( c  * VTAV.m02 ),
        ( cc * VTAV.m11 ) - mix + ( ss * VTAV.m22 ),
        0.0f,
        ( ss * VTAV.m11 ) + mix + ( cc * VTAV.m22 )
    );
}

Matrix3x3 rotate01Post( Matrix3x3 V, float c, float s ) {
    return createMatrix3x3(
        ( c * V.m00 ) - ( s * V.m01 ),
        ( s * V.m00 ) + ( c * V.m01 ),
        V.m02,
        ( c * V.m10 ) - ( s * V.m11 ),
        ( s * V.m10 ) + ( c * V.m11 ),
        V.m12,
        ( c * V.m20 ) - ( s * V.m21 ),
        ( s * V.m20 ) + ( c * V.m21 ),
        V.m22
    );
}

Matrix3x3 rotate02Post( Matrix3x3 V, float c, float s ) {
    return createMatrix3x3(
        ( c * V.m00 ) - ( s * V.m02 ),
        V.m01,
        ( s * V.m00 ) + ( c * V.m02 ),
        ( c * V.m10 ) - ( s * V.m12 ),
        V.m11,
        ( s * V.m10 ) + ( c * V.m12 ),
        ( c * V.m20 ) - ( s * V.m22 ),
        V.m21,
        ( s * V.m20 ) + ( c * V.m22 )
    );
}

Matrix3x3 rotate12Post( Matrix3x3 V, float c, float s ) {
    return createMatrix3x3(
        V.m00,
        ( c * V.m01 ) - ( s * V.m02 ),
        ( s * V.m01 ) + ( c * V.m02 ),
        V.m10,
        ( c * V.m11 ) - ( s * V.m12 ),
        ( s * V.m11 ) + ( c * V.m12 ),
        V.m20,
        ( c * V.m21 ) - ( s * V.m22 ),
        ( s * V.m21 ) + ( c * V.m22 )
    );
}

void rotate01( in out SymmetricMatrix3x3 VTAV, in out Matrix3x3 V ) {
    if( VTAV.m01 != 0.0f ) {
        float c = 0.0f;
        float s = 0.0f;

        calculateSymmetricGivensCoefficients( VTAV.m00, VTAV.m01, VTAV.m11, c, s );

        VTAV = rotate01( VTAV, c, s );

        c = 0.0f;
        s = 0.0f;

        V = rotate01Post( V, c, s );
    }
}

void rotate02( in out SymmetricMatrix3x3 VTAV, in out Matrix3x3 V ) {
    if( VTAV.m02 != 0.0f ) {
        float c = 0.0f;
        float s = 0.0f;

        calculateSymmetricGivensCoefficients( VTAV.m00, VTAV.m02, VTAV.m22, c, s );

        VTAV = rotate02( VTAV, c, s );

        c = 0.0f;
        s = 0.0f;

        V = rotate02Post( V, c, s );
    }
}

void rotate12( in out SymmetricMatrix3x3 VTAV, in out Matrix3x3 V ) {
    if( VTAV.m12 != 0.0f ) {
        float c = 0.0f;
        float s = 0.0f;

        calculateSymmetricGivensCoefficients( VTAV.m11, VTAV.m12, VTAV.m22, c, s );

        VTAV = rotate12( VTAV, c, s );

        c = 0.0f;
        s = 0.0f;

        V = rotate12Post( V, c, s );
    }
}

void getSymmetricSVD( SymmetricMatrix3x3 ATA, out SymmetricMatrix3x3 VTAV, out Matrix3x3 V ) {
    VTAV = ATA;
    V    = createMatrix3x3( 1.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f );

    float delta = SVD_TOLERANCE * frobeniusNorm( VTAV );

    for( uint sweep = 0; sweep < minimizerIterations && off( VTAV ) > delta; ++sweep ) {
        rotate01( VTAV, V );
        rotate02( VTAV, V );
        rotate12( VTAV, V );
    }
}

float pseudoInverse( float x ) {
    if( abs( x ) < PSEUDO_INVERSE_TOLERANCE ) {
        return 0.0f;
    }
    else {
        return abs( 1.0f / x ) < PSEUDO_INVERSE_TOLERANCE ? 0.0f : ( 1.0f / x );
    }
}

Matrix3x3 pseudoInverse( SymmetricMatrix3x3 VTAV, Matrix3x3 V ) {
    float d0 = pseudoInverse( VTAV.m00 );
    float d1 = pseudoInverse( VTAV.m11 );
    float d2 = pseudoInverse( VTAV.m22 );

    return createMatrix3x3(
        ( V.m00 * d0 * V.m00 ) + ( V.m01 * d1 * V.m01 ) + ( V.m02 * d2 * V.m02 ),
        ( V.m00 * d0 * V.m10 ) + ( V.m01 * d1 * V.m11 ) + ( V.m02 * d2 * V.m12 ),
        ( V.m00 * d0 * V.m20 ) + ( V.m01 * d1 * V.m21 ) + ( V.m02 * d2 * V.m22 ),
        ( V.m10 * d0 * V.m00 ) + ( V.m11 * d1 * V.m01 ) + ( V.m12 * d2 * V.m02 ),
        ( V.m10 * d0 * V.m10 ) + ( V.m11 * d1 * V.m11 ) + ( V.m12 * d2 * V.m12 ),
        ( V.m10 * d0 * V.m20 ) + ( V.m11 * d1 * V.m21 ) + ( V.m12 * d2 * V.m22 ),
        ( V.m20 * d0 * V.m00 ) + ( V.m21 * d1 * V.m01 ) + ( V.m22 * d2 * V.m02 ),
        ( V.m20 * d0 * V.m10 ) + ( V.m21 * d1 * V.m11 ) + ( V.m22 * d2 * V.m12 ),
        ( V.m20 * d0 * V.m20 ) + ( V.m21 * d1 * V.m21 ) + ( V.m22 * d2 * V.m22 )
    );
}

float calculateError( SymmetricMatrix3x3 ATA, float3 x, float3 ATB ) {
    Matrix3x3 A = createMatrix3x3( ATA );

    float3 V = ATB - multiplyVector( A, x );

    return dot( V, V );
}

void solveSVD( SymmetricMatrix3x3 ATA, float3 ATB, out float3 vertex, out float error ) {
    SymmetricMatrix3x3 VTAV;
    Matrix3x3          V;
    getSymmetricSVD( ATA, VTAV, V );

    vertex = multiplyVector( pseudoInverse( VTAV, V ), ATB );
    error  = calculateError( ATA, vertex, ATB );
}

void solveQEF( in out SVDQEF qef, out float3 vertex, out float3 normal, out float error ) {
    if( qef.intersectionCount > 0 ) {

        // copy QEF data into temporaries so the SVD solve doesn't affect future QEF combinations
        SymmetricMatrix3x3 ATA       = qef.ATA;
        float3             ATB       = qef.ATB;
        float3             massPoint = qef.massPoint;

        ATB -= multiplyVector( ATA, massPoint );

        solveSVD( ATA, ATB, vertex, error );

        vertex += massPoint;

        normal = calculateNormal   ( vertex );
        vertex = surfaceCorrection ( vertex, normal );
    }
    else {
        vertex = float3( 0.0f, 0.0f, 0.0f );
        normal = float3( 0.0f, 0.0f, 0.0f );
        error  = 0.0f;
    }
}

[numthreads( 1, 1 ,1 )]
void calculateMinimizingVertices( uint3 dispatchThreadID : SV_DispatchThreadID ) {
    uint voxelIndex = ( dispatchThreadID.z * resolution * resolution ) + ( dispatchThreadID.y * resolution ) + dispatchThreadID.x;

    bool allEmpty = true;
    bool allSolid = true;

    [unroll]
    for( uint voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {
        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        if( corners[cornerIndex].materialIndex >= MATERIAL_INDEX_VOID ) {
            allEmpty = false;
            break;
        }
    }

    [unroll]
    for( voxelCornerIndex = 0; voxelCornerIndex < VOXEL_CORNER_COUNT; ++voxelCornerIndex ) {
        uint cornerIndex = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndex;

        if( corners[cornerIndex].materialIndex == MATERIAL_INDEX_VOID ) {
            allSolid = false;
            break;
        }
    }

    if( !( allEmpty && allSolid ) ) {

        for( uint voxelEdgeIndex = 0; voxelEdgeIndex < VOXEL_EDGE_COUNT; ++voxelEdgeIndex ) {
            uint2 voxelCornerIndices = lookupCornersInEdge( voxelEdgeIndex );

            uint cornerIndex0 = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndices[0];
            uint cornerIndex1 = ( voxelIndex * VOXEL_CORNER_COUNT ) + voxelCornerIndices[1];

            bool intersectsContour = (
                corners[cornerIndex0].materialIndex == MATERIAL_INDEX_VOID && corners[cornerIndex1].materialIndex >= MATERIAL_INDEX_VOID
            ) || (
                corners[cornerIndex1].materialIndex == MATERIAL_INDEX_VOID && corners[cornerIndex0].materialIndex >= MATERIAL_INDEX_VOID
            );

            if( intersectsContour ) {
                uint edgeIndex = ( voxelIndex * VOXEL_EDGE_COUNT ) + voxelEdgeIndex;

                edges[edgeIndex].intersection = approximateIntersection( corners[cornerIndex0], corners[cornerIndex1] );
                edges[edgeIndex].normal       = calculateNormal( edges[edgeIndex].intersection );

                addToQEF( voxels[voxelIndex].qef, edges[edgeIndex].intersection, edges[edgeIndex].normal );
            }
        }

        float3 vertex = float3( 0.0f, 0.0f, 0.0f );
        float3 normal = float3( 0.0f, 0.0f, 0.0f );
        float  error  = 0.0f;

        solveQEF( voxels[voxelIndex].qef, vertex, normal, error );

        voxels[voxelIndex].vertex = vertex;
        voxels[voxelIndex].normal = normal;

    }
}